// frontend/old_Vercel/all_together_old_files

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// frontend/src/components/features/Auth/TelegramLoginWidget.jsx

import React, { useEffect, useState, useRef } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { Loader2 } from 'lucide-react';

export function TelegramLoginWidget({ onAuthSuccess, onAuthError, onAuthDecline }) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const widgetRef = useRef(null);
  const { signInWithTelegram } = useAuth();
//  const { signIn } = useAuth();

  useEffect(() => {
    // Create unique callback function name to avoid conflicts
    const callbackName = `onTelegramAuth_${Date.now()}`;

    // Define the callback function that handles Telegram auth response
    window[callbackName] = async (user) => {
      console.log('Telegram auth callback received:', user);
      setIsLoading(true);
      setError(null);

      try {
        // Handle user decline (user will be false)
        if (user === false) {
          console.log('User declined Telegram authorization');
          onAuthDecline?.();
          return;
        }

        // Validate user data
        if (!user || !user.id || !user.first_name || !user.hash) {
          throw new Error('Неполные данные авторизации от Telegram');
        }

        // Use AuthContext method for Telegram authentication
        const result = await signInWithTelegram(user);

        // Success callback
        onAuthSuccess?.(result);

      } catch (err) {
        console.error('Telegram auth error:', err);
        const errorMessage = err.message || 'Произошла ошибка при авторизации через Telegram';
        setError(errorMessage);
        onAuthError?.(errorMessage);
      } finally {
        setIsLoading(false);
      }
    };

    // Create and configure the Telegram widget script
    const script = document.createElement('script');
    script.src = "https://telegram.org/js/telegram-widget.js?22";
    script.async = true;
    script.setAttribute('data-telegram-login', import.meta.env.VITE_TELEGRAM_BOT_USERNAME);
    script.setAttribute('data-size', 'large');
    script.setAttribute('data-corner-radius', '8');
    script.setAttribute('data-onauth', `${callbackName}(user)`);
    script.setAttribute('data-request-access', 'write');

    // Insert script into widget container
    const widgetContainer = widgetRef.current;
    if (widgetContainer) {
      widgetContainer.appendChild(script);
    }

    // Cleanup function
    return () => {
      if (widgetContainer && script && widgetContainer.contains(script)) {
        widgetContainer.removeChild(script);
      }
      // Clean up global callback
      if (window[callbackName]) {
        delete window[callbackName];
      }
    };
  }, [onAuthSuccess, onAuthError, onAuthDecline]);

  // Show loading state during authentication
  if (isLoading) {
    return (
      <div className="flex items-center justify-center space-x-2 py-3 px-6 bg-[#0088cc] text-white rounded-lg">
        <Loader2 className="w-5 h-5 animate-spin" />
        <span>Авторизация...</span>
      </div>
    );
  }

  // Show error state if authentication failed
  if (error) {
    return (
      <div className="text-center space-y-2">
        <div className="text-sm text-red-400 bg-red-900/20 border border-red-500/30 rounded-lg p-3">
          {error}
        </div>
        <button
          onClick={() => {
            setError(null);
            // Force widget recreation by updating key
            if (widgetRef.current) {
              widgetRef.current.innerHTML = '';
              // Re-trigger useEffect by changing a dependency
              window.location.reload();
            }
          }}
          className="text-sm text-white/70 hover:text-white underline"
        >
          Попробовать снова
        </button>
      </div>
    );
  }

  // Widget container
  return (
    <div className="flex justify-center">
      <div ref={widgetRef} id="telegram-login-container" className="telegram-widget-container" />
    </div>
  );
}



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// frontend/src/components/features/Auth/TelegramLoginRedirect.jsx

import React, { useEffect, useRef } from 'react';

export function TelegramLoginRedirect({ returnTo = '/dashboard' }) {
  const ref = useRef(null);

  useEffect(() => {
    // --- ШАГ 1: "ЭКЗОРЦИЗМ" ---
    // Принудительно удаляем ВСЕ старые экземпляры виджета со страницы,
    // чтобы гарантировать, что останется только наша, правильная версия.
    document.querySelectorAll('script[data-telegram-login]').forEach(node => {
      try {
        node.remove();
      } catch (e) {
        console.warn("TelegramLoginRedirect: Failed to remove old widget script:", e);
      }
    });

    // Additional cleanup of any orphaned Telegram callback handlers
    if (window.Telegram) {
      try {
        delete window.Telegram;
      } catch (e) {
        // Silent fail - some contexts don't allow deletion
      }
    }

    // --- ШАГ 2: "ЗАПАСНОЙ КЛЮЧ" ---
    // Создаем ключ безопасности и сохраняем его в ДВУХ местах:
    // sessionStorage (основной) и localStorage (запасной для Я.Браузера).
    const state = crypto.randomUUID();
    sessionStorage.setItem('tg_oauth_state', state);
    localStorage.setItem('tg_oauth_state_last', state); // Запасной ключ

    const origin = window.location.origin;
    const authUrl = `${origin}/auth/telegram/callback?state=${encodeURIComponent(state)}&return_to=${encodeURIComponent(returnTo)}`;

    const botUsername = import.meta.env.VITE_TELEGRAM_BOT_USERNAME;
    if (!botUsername) {
      console.error('VITE_TELEGRAM_BOT_USERNAME is not defined');
      if (ref.current) ref.current.innerText = 'Ошибка конфигурации Telegram.';
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://telegram.org/js/telegram-widget.js?22';
    script.async = true;
    script.defer = true;
    script.setAttribute('data-telegram-login', botUsername);
    script.setAttribute('data-size', 'large');
    script.setAttribute('data-auth-url', authUrl);
    script.setAttribute('data-request-access', 'write');
    script.setAttribute('data-lang', 'ru');

    const container = ref.current;
    if (container) {
      container.innerHTML = '';
      container.appendChild(script);
    }

    return () => {
      if (container) {
        container.innerHTML = '';
      }
    };
  }, [returnTo]);

  return <div ref={ref} />;
}



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// frontend/src/pages/TelegramCallbackPage.jsx

import React, { useEffect, useState } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { supabase } from '@/lib/supabaseClient';
import { Loader2 } from 'lucide-react';
import { GlassPanel } from '@/components/ui/GlassPanel';

export function TelegramCallbackPage() {
  const [error, setError] = useState(null);
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();

  // Guard 1: Immediate redirect on SDK auth state change
  useEffect(() => {
    const { data: authListener } = supabase.auth.onAuthStateChange((event) => {
      if (event === 'SIGNED_IN') {
        const ret = searchParams.get('return_to') || '/dashboard';
        navigate(ret, { replace: true });
      }
    });
    return () => authListener?.subscription.unsubscribe();
  }, [navigate, searchParams]);

  // Guard 2: Timeout fallback - if session exists, navigate away
  useEffect(() => {
    const timeout = setTimeout(async () => {
      try {
        const { data } = await supabase.auth.getSession();
        if (data?.session) {
          const ret = searchParams.get('return_to') || '/dashboard';
          navigate(ret, { replace: true });
        }
      } catch (e) {
        // Silent fail
      }
    }, 3500);
    return () => clearTimeout(timeout);
  }, [navigate, searchParams]);

  // Main callback processing logic
  useEffect(() => {
    const completeLogin = async () => {
      // "Быстрый путь": если сессия уже есть, немедленно уходим.
      // Это чинит "зависший" спиннер.
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        navigate(searchParams.get('return_to') || '/dashboard', { replace: true });
        return;
      }

      const tgUserData = Object.fromEntries(searchParams.entries());
      const { state, return_to, ...telegramAuthData } = tgUserData;

      // Улучшенная проверка безопасности с "запасным ключом"
      const expectedState = sessionStorage.getItem('tg_oauth_state');
      const expectedStateBackup = localStorage.getItem('tg_oauth_state_last');

      sessionStorage.removeItem('tg_oauth_state');
      localStorage.removeItem('tg_oauth_state_last');

      if (!state || (state !== expectedState && state !== expectedStateBackup)) {
        console.error('Invalid state parameter. CSRF attack suspected.');
        setError('Ошибка безопасности. Пожалуйста, попробуйте войти снова.');
        setTimeout(() => navigate('/'), 5000);
        return;
      }

      try {
        const { data, error: invokeError } = await supabase.functions.invoke(
          'telegram-auth-callback',
          { body: { tgUserData: telegramAuthData } }
        );

        if (invokeError) throw invokeError;
        if (!data.success) throw new Error(data.error || 'Произошла неизвестная ошибка на сервере');

        const { error: sessionError } = await supabase.auth.setSession({
          access_token: data.session_token.access_token,
          refresh_token: data.session_token.refresh_token,
        });

        if (sessionError) throw sessionError;

        navigate(return_to || '/dashboard', { replace: true });

      } catch (err) {
        console.error('Ошибка на странице callback:', err);
        setError(`Ошибка авторизации: ${err.message}. Вы будете перенаправлены.`);
        setTimeout(() => navigate('/'), 5000);
      }
    };

    completeLogin();
  }, [navigate, searchParams]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-[url('/textures/dark_texture.png')] text-white text-center p-4">
      <GlassPanel className="p-10 rounded-2xl">
        {error ? (
          <>
            <h1 className="text-2xl font-brand text-red-400 mb-4">Ошибка</h1>
            <p>{error}</p>
          </>
        ) : (
          <>
            <Loader2 className="w-12 h-12 animate-spin mx-auto mb-4 text-gold-accent" />
            <h1 className="text-2xl font-brand">Завершаем вход...</h1>
            <p className="text-white/70">Пожалуйста, подождите.</p>
          </>
        )}
      </GlassPanel>
    </div>
  );
}



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// frontend/src/contexts/AuthContext.jsx

import React, { createContext, useState, useEffect, useContext, useRef } from 'react';
import { supabase, authAPI, clubMembersAPI } from '@/lib/supabaseClient';
import { validatedStorage } from '@/lib/validatedStorage';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const profileController = useRef(null);
  const isLoggingOut = useRef(false);
  const lastUserId = useRef(null);

  // Simple profile loading - no complex logic
  const loadUserProfile = async (user) => {
    console.log('🔄 [PROFILE-LOAD] Starting profile load for:', {
      userId: user?.id,
      userEmail: user?.email,
      isLoggingOut: isLoggingOut.current,
      lastUserId: lastUserId.current,
      hasExistingProfile: !!profile
    });

    if (!user || isLoggingOut.current) {
      console.log('❌ [PROFILE-LOAD] Early exit - no user or logging out');
      setProfile(null);
      return;
    }

    // Avoid duplicate profile loads for the same user
    if (lastUserId.current === user.id && profile) {
      console.log('⏭️ [PROFILE-LOAD] Profile already loaded for user:', user.id);
      return;
    }

    try {
      // Cancel previous profile request
      profileController.current?.abort();
      profileController.current = new AbortController();

      console.log('🔍 [PROFILE-LOAD] Querying club_members for user:', user.id);
      const memberProfile = await clubMembersAPI.getProfile(
        user.id,
        profileController.current.signal
      );

      console.log('📊 [PROFILE-LOAD] Query result:', {
        found: !!memberProfile,
        profileId: memberProfile?.id,
        nickname: memberProfile?.nickname,
        role: memberProfile?.role,
        telegramId: memberProfile?.telegram_id
      });

      setProfile(memberProfile);
      lastUserId.current = user.id;
      console.log('✅ [PROFILE-LOAD] Profile loaded and set for user:', user.id, 'role:', memberProfile?.role);

    } catch (profileError) {
      if (profileError.name !== 'AbortError') {
        console.error('❌ [PROFILE-LOAD] Profile loading failed:', {
          error: profileError.message,
          code: profileError.code,
          userId: user.id
        });
        setProfile(null);
        lastUserId.current = null;
      } else {
        console.log('⏹️ [PROFILE-LOAD] Profile load aborted');
      }
    }
  };

  // Ultra-simple logout - just clean everything
  const performCleanLogout = async () => {
    if (isLoggingOut.current) return;

    console.log('🚪 Simple logout...');
    isLoggingOut.current = true;

    // Cancel any ongoing requests
    profileController.current?.abort();

    // Clean local state first
    setUser(null);
    setProfile(null);
    setError(null);
    lastUserId.current = null;

    try {
      // Clean storage
      validatedStorage.purgeAllAuthArtifacts();
    } catch (e) {
      console.warn('Storage cleanup warning:', e);
    }

    try {
      // Supabase logout (don't wait for it)
      supabase.auth.signOut().catch(() => {});
    } catch (e) {
      // Ignore errors
    }

    // Simple page reload after a tiny delay
    setTimeout(() => {
      window.location.replace('/');
    }, 100);
  };

  // Minimal auth state handler
  useEffect(() => {
    console.log('🔧 Auth listener starting...');

    const { data: authListener } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log(`🔔 [AUTH-CONTEXT] ${event} - User:`, {
          userId: session?.user?.id || 'none',
          userEmail: session?.user?.email || 'none',
          hasSession: !!session,
          currentProfileId: profile?.id || 'none',
          isLoggingOut: isLoggingOut.current,
          loading
        });

        // Always ignore events during logout
        if (isLoggingOut.current) {
          console.log('🚫 [AUTH-CONTEXT] Ignoring event - logging out');
          return;
        }

        const currentUser = session?.user ?? null;

        // Simple state updates
        console.log('📝 [AUTH-CONTEXT] Setting user state:', !!currentUser);
        setUser(currentUser);

        if (currentUser) {
          // Only load profile on SIGNED_IN or if we don't have one
          const shouldLoadProfile = event === 'SIGNED_IN' || !profile || lastUserId.current !== currentUser.id;
          console.log('🔍 [AUTH-CONTEXT] Profile loading decision:', {
            event,
            shouldLoad: shouldLoadProfile,
            hasProfile: !!profile,
            lastUserId: lastUserId.current,
            currentUserId: currentUser.id
          });

          if (shouldLoadProfile) {
            console.log('⏳ [AUTH-CONTEXT] Starting async profile load for user:', currentUser.id);
            // DON'T AWAIT - let profile loading happen in parallel
            loadUserProfile(currentUser).catch(error => {
              console.error('❌ [AUTH-CONTEXT] Profile loading failed:', error);
            });
          } else {
            console.log('⏭️ [AUTH-CONTEXT] Skipping profile load');
          }
        } else {
          // No user - clear everything
          console.log('🧹 [AUTH-CONTEXT] Clearing user data');
          setProfile(null);
          lastUserId.current = null;
        }

        // Turn off loading after first event
        if (loading) {
          console.log('✅ [AUTH-CONTEXT] Turning off loading state');
          setLoading(false);
        }

        console.log('🏁 [AUTH-CONTEXT] Event processing complete');
      }
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, [loading, profile]); // Minimal dependencies

  // Simple auth functions
  const signIn = async (data) => {
    try {
      const result = await supabase.auth.signInWithPassword(data);
      if (result.error) {
        setError(result.error.message);
      }
      return result;
    } catch (error) {
      setError(error.message);
      throw error;
    }
  };

  const signUp = async (data) => {
    const result = await supabase.auth.signUp(data);
    if (result.error) {
      setError(result.error.message);
    }
    return result;
  };

  const signInWithTelegram = async (telegramUserData) => {
    setLoading(true);
    try {
      setError(null);

      const { data, error: invokeError } = await supabase.functions.invoke(
        'telegram-auth-callback',
        { body: { tgUserData: telegramUserData } }
      );

      if (invokeError) throw new Error(invokeError.message || 'Telegram auth failed');
      if (!data.success) throw new Error(data.error || 'Unknown error');

      if (data.session_token) {
        const { error: sessionError } = await supabase.auth.setSession({
          access_token: data.session_token.access_token,
          refresh_token: data.session_token.refresh_token,
        });

        if (sessionError) throw new Error('Failed to set session');
      } else {
        setLoading(false);
        throw new Error('No session token');
      }

      return { success: true, ...data };
    } catch (error) {
      setError(`Telegram error: ${error.message}`);
      setLoading(false);
      throw error;
    }
  };

  const signOut = async () => {
    await performCleanLogout();
  };

  const value = {
    user,
    profile,
    loading,
    error,
    signIn,
    signUp,
    signOut,
    signInWithTelegram,
    nickname: profile?.nickname,
    role: profile?.role,
    isAdmin: profile?.role === 'admin',
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// frontend/src/lib/supabaseClient.js

import { createClient } from '@supabase/supabase-js'
import { validatedStorage } from './validatedStorage.js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

console.log("CHECKING ENV VARS -> Supabase URL:", supabaseUrl);
console.log("CHECKING ENV VARS -> Supabase Key:", supabaseAnonKey ? "Key Found" : "Key NOT Found or empty");

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: validatedStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
})

// ===== DATABASE HELPER FUNCTIONS FOR NEW NORMALIZED SCHEMA =====

// Club Members Table Operations (public.club_members)
export const clubMembersAPI = {
  // --- ИЗМЕНЕНИЯ ТОЛЬКО ЗДЕСЬ ---
  async getProfile(userId, signal) {
    const { data, error } = await supabase
      .from('club_members')
      .select('*') // Выбираем все поля, включая role
      .eq('user_id', userId)
      .maybeSingle()
      .abortSignal(signal); // ✅ ПРАВИЛЬНЫЙ СПОСОБ ПЕРЕДАЧИ СИГНАЛА

    if (error) {
      if (error.name !== 'AbortError') {
        console.error('Error fetching club member profile:', error);
      }
      throw error;
    }
    return data;
  },
  // --- КОНЕЦ ИЗМЕНЕНИЙ ---

  // Обновить профиль по user_id
  async updateProfile(userId, updates = {}) {
    const allowedUpdates = (({ nickname, full_name, avatar_url, telegram_id, telegram_username }) => ({
      ...(nickname !== undefined && { nickname }),
      ...(full_name !== undefined && { full_name }),
      ...(avatar_url !== undefined && { avatar_url }),
      ...(telegram_id !== undefined && { telegram_id }),
      ...(telegram_username !== undefined && { telegram_username }),
    }))(updates);

    if (Object.keys(allowedUpdates).length === 0) {
        console.log("No valid fields to update.");
        return null;
    }

    const { data, error } = await supabase
      .from('club_members')
      .update(allowedUpdates)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }
};

// Tournaments Table Operations (public.tournaments)
export const tournamentsAPI = {
  // ... (остальной код без изменений)

    // --- НАЧАЛО ДОБАВЛЕНИЯ ---
  /**
   * Fetches tournaments that are eligible for completion/simulation.
   * @returns {Promise<Array>} A list of tournaments with 'scheduled' or 'registration_open' status.
   */
  async getCompletableTournaments() {
    const { data, error } = await supabase
      .from('tournaments')
      .select('id, name')
      .in('status', ['scheduled', 'registration_open'])
      .order('tournament_date', { ascending: true });

    if (error) {
      console.error('Error fetching completable tournaments:', error);
      throw error;
    }
    return data;
  },
  // --- КОНЕЦ ДОБАВЛЕНИЯ ---


  async getActiveTournaments() {
    const { data, error } = await supabase
      .from('tournaments')
      .select('*')
      .eq('is_active_for_registration', true)
      .order('tournament_date', { ascending: true });

    if (error) throw error;
    return data || [];
  },
  async getTournament(id) {
    const { data, error } = await supabase
      .from('tournaments')
      .select('*')
      .eq('id', id)
      .single();

    if (error) throw error;
    return data;
  },
  async getAllTournaments() {
    const { data, error } = await supabase
      .from('tournaments')
      .select('*')
      .order('tournament_date', { ascending: false });

    if (error) throw error;
    return data || [];
  },
  async createTournament(tournamentData) {
    const { data, error } = await supabase
      .from('tournaments')
      .insert([tournamentData])
      .select()
      .single();

    if (error) throw error;
    return data;
  },
  async updateTournament(id, updates) {
    const { data, error } = await supabase
      .from('tournaments')
      .update(updates)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return data;
  },
  async deleteTournament(id) {
    const { error } = await supabase
      .from('tournaments')
      .delete()
      .eq('id', id);

    if (error) throw error;
  },
  async findNearestTournament() {
    const now = new Date().toISOString();
    const { data, error } = await supabase
      .from('tournaments')
      .select('id')
      .eq('is_active_for_registration', true)
      .gte('tournament_date', now)
      .order('tournament_date', { ascending: true })
      .limit(1)
      .maybeSingle();

    if (error) throw error;
    return data?.id || null;
  }
};

// Authentication Helper Functions
export const authAPI = {
  // ... (остальной код без изменений)
  async signUpClubMember(email, password, nickname) {
    const { data, error } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          nickname: nickname,
          full_name: nickname
        }
      }
    });

    if (error) throw error;
    return data;
  },
  async getCurrentUserWithProfile() {
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError) throw authError;
    if (!user) return { user: null, profile: null };

    try {
      const profile = await clubMembersAPI.getProfile(user.id);
      return { user, profile };
    } catch (profileError) {
      return { user, profile: null };
    }
  }
};


////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// frontend/src/lib/validatedStorage.js

/**
 * ValidatedStorage - A localStorage wrapper that validates Supabase auth tokens
 * before they reach the SDK, preventing blank page issues from corrupted sessions.
 */
class ValidatedStorage {
  constructor() {
    this.isDevMode = import.meta.env.DEV;
    this.initializeDevMode();
  }

  /**
   * Development  mode initialization
   */
  initializeDevMode() {
    if (!this.isDevMode) return;

    // Clear potentially corrupted tokens on dev server restart
    const devSessionKey = 'validatedStorage.devSession';
    const currentSession = Date.now().toString();
    const lastSession = localStorage.getItem(devSessionKey);

    if (!lastSession || lastSession !== currentSession) {
      // New dev session detected - clean up auth tokens
      this.cleanupAuthTokens();
      localStorage.setItem(devSessionKey, currentSession);
      console.log('ValidatedStorage: Dev mode - cleaned auth tokens for fresh session');
    }
  }

  /**
   * Clean up all Supabase auth tokens (development helper)
   */
  cleanupAuthTokens() {
    try {
      const keysToRemove = [];

      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (this.isSupabaseAuthKey(key)) {
          keysToRemove.push(key);
        }
      }

      keysToRemove.forEach(key => {
        localStorage.removeItem(key);
      });

      if (keysToRemove.length > 0 && this.isDevMode) {
        console.log(`ValidatedStorage: Cleaned ${keysToRemove.length} auth tokens`);
      }
    } catch (error) {
      console.warn('ValidatedStorage: Error cleaning auth tokens:', error);
    }
  }

  /**
   * Bulletproof logout - purges ALL auth artifacts from both storages
   * Used for logout scenarios where we need to ensure no rehydration
   */
  purgeAllAuthArtifacts() {
    try {
      const removedKeys = [];

      // Clean localStorage - all sb-* keys and auth variations
      for (let i = localStorage.length - 1; i >= 0; i--) {
        const key = localStorage.key(i);
        if (key && (
          key.startsWith('sb-') ||
          key.includes('supabase') ||
          key.includes('auth-token') ||
          key === 'tg_oauth_state_last'
        )) {
          localStorage.removeItem(key);
          removedKeys.push(key);
        }
      }

      // Clean sessionStorage - all auth-related keys
      try {
        sessionStorage.removeItem('tg_oauth_state');
        for (let i = sessionStorage.length - 1; i >= 0; i--) {
          const key = sessionStorage.key(i);
          if (key && (
            key.startsWith('sb-') ||
            key.includes('supabase') ||
            key.includes('auth')
          )) {
            sessionStorage.removeItem(key);
            removedKeys.push(`session:${key}`);
          }
        }
      } catch (e) {
        // sessionStorage might not be available in some contexts
      }

      console.log(`ValidatedStorage: Purged ${removedKeys.length} auth artifacts for clean logout`);
      return removedKeys.length;
    } catch (error) {
      console.warn('ValidatedStorage: Error purging auth artifacts:', error);
      return 0;
    }
  }

  /**
   * Validates if the auth session data is structurally correct
   * CRITICAL: Only validates essential structure, lets Supabase handle expiration/refresh
   */
  isValidAuthSession(sessionData) {
    try {
      // The only checks we need are for the absolute minimum required fields.
      // We DO NOT check for email or expiration time.
      if (!sessionData?.access_token || !sessionData?.user?.id) {
        return false;
      }
      return true;
    } catch {
      // If parsing or access fails for any reason, treat as invalid.
      return false;
    }
  }

  /**
   * Checks if a localStorage key is a Supabase auth token
   */
  isSupabaseAuthKey(key) {
    return key && (
      key.includes('supabase.auth.token') ||
      key.includes('sb-') && key.includes('auth-token') ||
      key.includes('supabase-auth-token')
    );
  }

  /**
   * Validates and cleans auth data
   */
  validateAndCleanAuthData(value) {
    if (!value) return null;

    try {
      const parsed = JSON.parse(value);

      // If it's a valid session, return original value
      if (this.isValidAuthSession(parsed)) {
        return value;
      }

      // If invalid, log and return null (which means "no session" to Supabase)
      if (this.isDevMode) {
        console.log('ValidatedStorage: Removing structurally invalid auth session (missing access_token or user.id)');
      }

      // Clean up the corrupted token from localStorage
      return null;

    } catch (error) {
      // Corrupted JSON - return null
      if (this.isDevMode) {
        console.log('ValidatedStorage: Removing corrupted auth JSON:', error.message);
      }
      return null;
    }
  }

  /**
   * localStorage wrapper methods
   */
  getItem(key) {
    try {
      const value = localStorage.getItem(key);

      // Only validate Supabase auth keys
      if (this.isSupabaseAuthKey(key)) {
        const validatedValue = this.validateAndCleanAuthData(value);

        // If we cleaned a corrupted token, remove it from localStorage
        if (value && !validatedValue) {
          localStorage.removeItem(key);
          if (this.isDevMode) {
            console.log('ValidatedStorage: Cleaned corrupted token from localStorage');
          }
        }

        return validatedValue;
      }

      // Return other keys unchanged
      return value;
    } catch (error) {
      console.error('ValidatedStorage: Error in getItem:', error);
      return null;
    }
  }

  setItem(key, value) {
    try {
      localStorage.setItem(key, value);
    } catch (error) {
      console.error('ValidatedStorage: Error in setItem:', error);
    }
  }

  removeItem(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error('ValidatedStorage: Error in removeItem:', error);
    }
  }

  clear() {
    try {
      localStorage.clear();
    } catch (error) {
      console.error('ValidatedStorage: Error in clear:', error);
    }
  }

  key(index) {
    try {
      return localStorage.key(index);
    } catch (error) {
      console.error('ValidatedStorage: Error in key:', error);
      return null;
    }
  }

  get length() {
    try {
      return localStorage.length;
    } catch (error) {
      console.error('ValidatedStorage: Error getting length:', error);
      return 0;
    }
  }
}

// Export singleton instance
export const validatedStorage = new ValidatedStorage();

// Log validation fix deployment for debugging
if (import.meta.env.DEV) {
  console.log('🔧 ValidatedStorage: Using simplified validation (no email/expiration checks)');
}

// Utility functions for manual testing and recovery
export const clearCorruptedAuthTokens = () => {
  validatedStorage.cleanupAuthTokens();
  console.log('✅ Auth tokens cleared. Please refresh the page.');
};

export const testLogoutCleanup = () => {
  const purgedCount = validatedStorage.purgeAllAuthArtifacts();
  console.log(`✅ Logout test: Purged ${purgedCount} auth artifacts.`);
  return purgedCount;
};

export const inspectAuthState = async () => {
  const sbKeys = Object.keys(localStorage).filter(k => k.startsWith('sb-'));
  const sessionKeys = Object.keys(sessionStorage).filter(k => k.startsWith('sb-') || k.includes('auth'));

  console.log('🔍 Auth state inspection:');
  console.log('- localStorage sb-* keys:', sbKeys.length, sbKeys);
  console.log('- sessionStorage auth keys:', sessionKeys.length, sessionKeys);

  return { localStorage: sbKeys, sessionStorage: sessionKeys };
};

// Make utilities available globally for debugging
if (typeof window !== 'undefined') {
  window.clearCorruptedAuthTokens = clearCorruptedAuthTokens;
  window.testLogoutCleanup = testLogoutCleanup;
  window.inspectAuthState = inspectAuthState;

  if (import.meta.env.DEV) {
    console.log('🛠️ Auth debugging utilities available: clearCorruptedAuthTokens(), testLogoutCleanup(), inspectAuthState()');
  }
}


////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />

    <!-- Canonical — фиксируем главный домен -->
    <link rel="canonical" href="https://www.ipoker.style/" />

    <!-- Title & SEO -->
    <title>IPS — International Poker Style</title>
    <meta
      name="description"
      content="Закрытый клуб спортивного покера: расписание турниров, рейтинг игроков и быстрая запись."
    />
    <meta name="robots" content="index,follow" />
    <meta name="theme-color" content="#0b0f12" />

    <!-- Open Graph / Social -->
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="IPS Poker Style" />
    <meta property="og:title" content="IPS — International Poker Style" />
    <meta
      property="og:description"
      content="Запишись на ближайший турнир. Премиальная атмосфера, рейтинги и личный кабинет."
    />
    <meta property="og:url" content="https://www.ipoker.style/" />
    <!-- укажи реальный путь к обложке (1200×630) -->
    <meta property="og:image" content="https://www.ipoker.style/og/cover.jpg" />
    <meta name="twitter:card" content="summary_large_image" />

    <!-- Иконки -->
    <link rel="icon" type="image/svg+xml" href="/logo/Logo_IPS.svg" />
    <link rel="icon" sizes="any" href="/favicon.ico" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <!-- если сделаешь PWA-манифест -->
    <!-- <link rel="manifest" href="/site.webmanifest" /> -->

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Syne:wght@700;800&display=swap"
      rel="stylesheet"
    />

    <!-- (Опционально) чуть безопаснее реферер -->
    <meta name="referrer" content="strict-origin-when-cross-origin" />
  </head>

  <body>
    <noscript>Для работы сайта необходим JavaScript.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// supabase/functions/telegram-auth-callback/index.ts

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3'

// ---------- CORS ----------
const ALLOW_ORIGINS = [
  'https://www.ipoker.style',
  'https://ips-entertain.xyz',
  'http://localhost:5173',
]
function corsHeaders(req: Request) {
  const origin = req.headers.get('origin') ?? ''
  const allowed = ALLOW_ORIGINS.includes(origin) ? origin : '*'
  return {
    'Access-Control-Allow-Origin': allowed,
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
  }
}
const json = (req: Request, body: unknown, init: ResponseInit = {}) =>
  new Response(JSON.stringify(body), {
    headers: { ...corsHeaders(req), 'Content-Type': 'application/json' },
    ...init,
  })

// ---------- Telegram hash verify ----------
async function verifyTelegramHash(userData: any, botToken: string): Promise<boolean> {
  const { hash, ...dataToCheck } = userData
  const checkString = Object.keys(dataToCheck)
    .sort()
    .map((k) => `${k}=${dataToCheck[k]}`)
    .join('\n')

  const secretKeyData = new TextEncoder().encode(botToken)
  const secretKey = await crypto.subtle.digest('SHA-256', secretKeyData)
  const key = await crypto.subtle.importKey('raw', secretKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign'])
  const signature = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(checkString))
  const hex = Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, '0')).join('')
  return hex === hash
}

// минутная защита от реплея (по желанию)
function isFreshAuth(auth_date?: number, maxAgeSec = 300) {
  if (!auth_date) return false
  const now = Math.floor(Date.now() / 1000)
  return now - auth_date <= maxAgeSec
}

// ---------- Password grant ----------
async function passwordGrant(email: string, password: string) {
  const url = `${Deno.env.get('SUPABASE_URL')}/auth/v1/token?grant_type=password`
  const anon = Deno.env.get('SUPABASE_ANON_KEY')!
  return fetch(url, {
    method: 'POST',
    headers: {
      apikey: anon,
      Authorization: `Bearer ${anon}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ email, password }),
  })
}

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') return new Response('ok', { headers: corsHeaders(req) })

  try {
    const body = await req.json().catch(() => ({}))
    const DEBUG = Deno.env.get('DEBUG_TELEGRAM_BYPASS') === 'true'

    let tg: any = body?.tgUserData
    if (!tg && DEBUG && body?.debug?.id) {
      console.log('--- DEBUG MODE: telegram bypass ---')
      tg = {
        id: body.debug.id,
        username: body.debug.username ?? 'debuguser',
        first_name: body.debug.first_name ?? 'Debug',
        last_name: body.debug.last_name ?? 'User',
        photo_url: null,
        auth_date: Math.floor(Date.now() / 1000),
        hash: 'DEBUG_BYPASS',
      }
    }
    if (!tg) return json(req, { success: false, error: 'Отсутствуют данные авторизации Telegram.' }, { status: 400 })

    const telegramId = Number(tg.id)
    if (!telegramId) return json(req, { success: false, error: 'Невалидный Telegram ID.' }, { status: 400 })

    // — prod-безопасность —
    if (!DEBUG) {
      const botToken = Deno.env.get('TELEGRAM_CLIENT_SECRET')
      if (!botToken) return json(req, { success: false, error: 'Нет TELEGRAM_CLIENT_SECRET.' }, { status: 500 })
      if (!isFreshAuth(tg.auth_date)) {
        return json(req, { success: false, error: 'Просроченные данные авторизации.' }, { status: 401 })
      }
      const ok = await verifyTelegramHash(tg, botToken)
      if (!ok) return json(req, { success: false, error: 'Ошибка проверки подписи Telegram.' }, { status: 401 })
    }

    const SHADOW = Deno.env.get('SHADOW_PASSWORD_SECRET')
    if (!SHADOW) return json(req, { success: false, error: 'Нет SHADOW_PASSWORD_SECRET.' }, { status: 500 })

    const email = `tg_${telegramId}@telegram.user`
    const password = `${SHADOW}:${telegramId}`

    // 1) пробуем войти (если уже есть)
    let res = await passwordGrant(email, password)
    if (res.ok) {
      const tokens = await res.json()
      return json(req, { success: true, session_token: tokens })
    }

    // 2) создаём пользователя и повторяем вход
    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    )

    const fullName = `${tg.first_name || ''} ${tg.last_name || ''}`.trim()
    const metadata = {
      provider: 'telegram',
      telegram_id: telegramId,
      username: tg.username ?? null,
      full_name: fullName || null,
      avatar_url: tg.photo_url ?? null,
      nickname: tg.username || tg.first_name || `tg_${telegramId}`,
    }

    const { data: created, error: createErr } = await supabaseAdmin.auth.admin.createUser({
      email,
      password,
      email_confirm: true,
      user_metadata: metadata,
    })

    if (createErr) {
      // возможна ситуация «пользователь уже есть» — просто идём дальше к логину
      console.warn('createUser error:', createErr.message || createErr)
    } else {
      console.log('user created:', created.user?.id)
    }

    res = await passwordGrant(email, password)
    if (!res.ok) {
      const text = await res.text()
      return json(
        req,
        { success: false, error: `Password grant failed: ${res.status} ${text}` },
        { status: 500 }
      )
    }

    const tokens = await res.json()
    return json(req, { success: true, session_token: tokens })
  } catch (e: any) {
    console.error('Telegram Auth Failed:', e?.message || e)
    return json(req, { success: false, error: e?.message || 'Unknown error' }, { status: 500 })
  }
})



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

// vite.config.js
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from 'tailwindcss'
import autoprefixer from 'autoprefixer'
import path from 'path'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')

  // "Очищаем" хост от лишних протоколов и слэшей, чтобы защитить HMR
  const rawHost = env.VITE_PUBLIC_HOST || 'localhost'
  const PUBLIC_HOST = rawHost.replace(/^https?:\/\//, '').replace(/\/+$/, '');

  return {
    plugins: [react()],
    css: {
      postcss: {
        plugins: [tailwindcss, autoprefixer],
      },
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    server: {
      host: true,
      port: 5173,
      allowedHosts: [PUBLIC_HOST],
      origin: `https://${PUBLIC_HOST}`,
      hmr: {
        host: PUBLIC_HOST, // Теперь сюда передается "чистый" хост
        protocol: 'wss',
        clientPort: 443,
      },
    },
    preview: {
      allowedHosts: [PUBLIC_HOST],
    },
  }
})



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////




